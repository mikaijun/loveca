Cursor Project Rules — 実用的なフロントエンド設計指針（DDD簡易版）
目標

UI ロジックと業務ルールを適度に分離し、メンテナンス性を向上させる。

小規模アプリケーションでは過度な抽象化を避け、シンプルで理解しやすい構造を優先する。

必要に応じて値オブジェクト・エンティティを使用するが、実用性を重視する。サービス層は廃止し、entityから直接関数を使用する。

ディレクトリ指針
src/
├── app/ # 画面/ルーティング層（Next.js App Router）
├── components/ # UI層（ページとfeatureコンポーネント）
│ ├── pages/ # ページコンポーネント（ビジネスロジック統合可）
│ ├── features/ # 機能別UIコンポーネント
│ ├── commons/ # 共通UIコンポーネント
│ └── ui/ # 基本UIコンポーネント
├── domain/ # ビジネスロジック層
│ ├── valueObjects/ # 複雑な制約のある値のみ
│ └── entities/ # 状態管理が必要なオブジェクト（サービス機能も含む）
├── constants/ # 定数・設定値
└── utils.ts # ユーティリティ関数

命名・原則

値オブジェクト：複雑な制約やバリデーションが必要な場合のみ使用。単純な数値・文字列は直接使用も可。

状態遷移の明示：エンティティは withXxx などで不変な状態遷移を表現。

横断判定はentity：複数エンティティをまたぐ計算・バリデーションはentity内の関数として実装。

フック設計：React hooksから直接entity関数を呼び出し。サービス層は廃止し、過度な抽象化を避ける。

UI 統合：小規模なコンポーネントはページ内統合も可。再利用性より理解しやすさを重視。

値オブジェクト（Value Object）

複雑な制約やドメイン固有のルールがある場合に使用。単純な値は通常の型でも可。

例：HeartColor は有効な色のみを許可、複雑な変換ロジックを内包。

使い分け：

- 複雑な制約 → 値オブジェクト（例：HeartColor）
- 単純な範囲制約 → 関数でバリデーション（例：0-40の数値）
- 基本的な値 → そのまま使用（例：boolean）

エンティティ（Entity）

状態の集合体として設計。簡潔な値は直接プロパティとして持つ。

例：HeartState は color、count、visibilityを持ち、withXxx関数で不変な状態変更を提供。

実用的な設計：

- 重要な状態遷移のみエンティティ化
- 単純な値の更新は直接代入も可
- 過度な抽象化より理解しやすさを重視

エンティティ（Entity）の拡張

状態管理に加えて、複数エンティティをまたぐ計算・バリデーションも担当。

設計指針：

- 1つのエンティティに置くと不自然な横断ルールはentity内の関数として実装
- ステートレス関数として実装し、テスト容易性を高める
- UI から直接 if 文で判定しない

React Hooks（簡易ユースケース層）

小規模アプリではReact hooksが実質的なユースケース層として機能。

設計指針：

- hooksから直接entity関数を呼び出し
- 状態管理とエラーハンドリングを担当
- 必要に応じてバリデーション実行
- UI用の状態に整形して返す

過度な抽象化より直接的で理解しやすい構造を優先。

型と安全性

生成系は createXxx、変更は withXxx / applyXxx、比較は equalsXxx を徹底。

例外を投げる代わりに Result/Either を返すのも可（チーム規約に従う）。

UI 実装ルール（React/TS）

基本方針：複雑な業務ロジックはhooksまたはdomain servicesに委譲。

許可される例外：

- 小規模なUIロジック（表示/非表示切り替え等）はコンポーネント内でも可
- ページコンポーネント内での関連コンポーネント統合
- 単純なバリデーション（入力値チェック等）

重要な業務ルールのみ分離し、過度な分離は避ける。

実装例（heartCounter構造）

// domain/valueObjects/heartColor.ts（複雑なルールあり）
export type HeartColor = 'pink' | 'blue' | 'yellow' | 'green' | 'purple' | 'gray'
export function createHeartColor(value: string): HeartColor {
if (!VALID_COLORS.includes(value)) throw new Error('無効な色')
return value as HeartColor
}

// domain/entities/heart/collection.ts（状態管理 + 横断ロジック）
export type Heart = {
color: HeartColor
count: number // 直接number使用（単純な値）
visibility: boolean // 直接boolean使用
}

export function withIncrementedCount(state: Heart): Heart {
return { ...state, count: state.count + 1 }
}

// 横断ロジックもentity内に実装
export function calculateTotalRequiredBladeHearts(
requiredLiveHearts: HeartCollection,
memberHearts: HeartCollection
): number {
// 複雑な計算ロジック
}

// components/pages/HeartManagerPage/HeartManagerPage.hooks.ts（React hooks = 簡易ユースケース）
export const useColorfulHeartManager = () => {
const [colorfulHeartState, setColorfulHeartState] = useState(() => ({
requiredLiveHearts: createRequiredLiveHeartCollection(),
memberHearts: createMemberHeartCollection(),
}))

const handleIncrementRequiredLiveHeart = useCallback(
(color: HeartIconProps['color']) => {
setColorfulHeartState((prev) => {
const newRequiredLiveHearts = withIncrementedHeartCount(
prev.requiredLiveHearts,
color
)
return {
...prev,
requiredLiveHearts: newRequiredLiveHearts,
}
})
},
[]
)

return { handleIncrementRequiredLiveHeart, ... }
}

// components/pages/HeartManagerPage/HeartManagerPage.tsx（統合UI）
const HeartManagerPage = () => {
const { colorful, monochrome } = useHeartManager()

return (
<Tabs.Root>
<Tabs.Content value="tab1">
<ColorfulHeartManager {...colorful} />
</Tabs.Content>
<Tabs.Content value="tab2">
<MonochromeHeartManager {...monochrome} />
</Tabs.Content>
</Tabs.Root>
)
}

（考え方と例は記事の記述を要約・再構成しています。
Qiita
）

テスト戦略

値オブジェクト：生成・演算・比較の性質テスト。

エンティティ：無効遷移の拒否と有効遷移の結果。

entity内の横断ロジック：複数入力に対する判定境界（合計 =/≠ 必要量）。

ユースケース：ドメイン組み合わせ + infra のモックで分岐網羅。

設計指針のバランス

推奨パターン：
✅ 複雑な計算・バリデーションはentity内の関数として実装
✅ 状態管理が必要な場合はエンティティ化
✅ 複雑な制約がある値は値オブジェクト化
✅ React hooksでの直接的なentity関数呼び出し
✅ 理解しやすさを重視した適度な統合
✅ サービス層は廃止し、entityに集約

注意すべき過度な抽象化：
❌ 単純な値まで全て値オブジェクト化
❌ 不要なユースケース層の追加
❌ 過度なコンポーネント分離
❌ 複雑すぎる責務分離
❌ 不要なサービス層の追加

導入指針：

1. まずは既存コードのまま動作させる
2. 複雑になった部分のみ段階的にドメイン層に移行
3. 実用性と理解しやすさのバランスを重視
4. 小規模チームでは厳格すぎるルールより実用性優先
5. サービス層は廃止し、entityに機能を集約
